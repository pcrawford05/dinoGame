Project I built over the summer using my EE109 project kit (Thank you Prof. Weber for lending it to me so I could build cool things like this).
It was a lot of fun reviewing concepts from EE 109 like interrupts, EEPROM, and PWM. I tried to use as many of the concepts that I knew in this project and very much enjoyed it.

I ended up using all 3 timers of the arduino: 1 for the buzzer, 1 for the score, and 1 for the PWM for the LED. I was really glad I didn't have to start from complete scratch as I had some files for the lcd written already and had some other basic ISR calls I could reference. One of the hardest things to implement was honestly nothing and everything. It felt like any time I tried to do anything a bunch of problems came up, I had to think about it, check my previous labs and lab writeups, then check Stack Overflow, and then I finally fixed it. This includes adding the buttons to the breadboard (rather than using the LCD buttons), adding the LED, adding the Buzzer, adding speed, adding EEPROM capabilities, and adding the helper functions for the actual game functionality.

There are a few ways I could've made this game better, some of which I tried others which I did not (which may give me a reason to come back to this). I tried to add specialized obstacles but found it impossible without coding in the Arduino IDE so I had to use characters that were symmetrical in nature (I chose W and M to act as stalactites and stalagmites). The levelUp sound is not super elegant but my sister said it was good enough after telling me my previous version was bad so I left that as is. I left the obstacle generation as completely random (so walls could appear and make it impossible to pass). Funnily enough, somehow when I was first making this game I glitched through one of the walls but I was unable to replicate this move every other time I tried. The only time I used AI was to try to figure out the best seed but it didn't give me a good value, I decided to create my own program to determine this, and faced a bunch of issues (it just being wrong about how long one could go). I then checked Stack Overflow and people there said rand/srand are not good so I think my separate file was just coming up with different RNG's.

My biggest takeaways from this project are the value of Stack Overflow, the awesomeness of a highly tactile game, and the importance of persistance when debugging.

Overall this project took about 2 weeks of work spread out over a month and total working hours was probably around 25. I got my inspiration from the Dinosaur Game on Chrome.


step 1: add as much specifcity as possible!

my proposed order:
Demo: https://youtube.com/shorts/N5O_s678hBg?feature=share
Context:
Spring 2025 semester I took a very engaging and interesting class called Intro to Embedded Systems. I liked it so much in fact that I switched my major from pure Computer Science to Computer Engineering and Computer Science (after talking with the professor, Prof. Weber). We built really cool projects with an Arduino Uno and an LCD shield in the lab inlcuding a temperature monitoring embedded system. At the end of the class I was delaying turning in my project kit (partially out of laziness, and partially because I didn't want to give up the cool tools I've been playing with). After another conversation with Prof. Weber, he let me keep the kit over the summer to work on any project I liked. This is the result of that. The inspiration for this project is the Google Chrome Dinosaur game but I'm not exactly sure where it came from (trust me I was focused in this class not playing games). The following is the story of my implementation, challenges, and insights from building dinoGame. I hope you enjoy.

Implementation:
For this project, I wanted to use as many concepts from EE109 as possible and I hope you see that in the implementation. First, the LCD screen has two rows on it so I knew I couldn't implement jumping but I could do some sort of dodging where the obstacles come at you from right to left. I started by using the LCD buttons to make the game very compact but then realized that I wanted to add an LED somehow and a buzzer so I would need a breadboard. Since I had a breadboard, I knew I wanted to add bigger buttons for the player to use. At this point in the project while it was still very early I made a list at the top of my code of all the things I wanted to implement: LED that changed color (red/green (brighter/darker)), local memory storage for high score (even when it loses power), increasing speed of obstacles, seed function so that you would get different obstacles, a buzzer for something, real buttons, designed obstacles, scoring (high scores), ______ (blank space for more ideas to come). Then, when I had inspiration to work on the project, I'd look at my feature list and did my best to implement them. I had the basics of the game down at the beginning while still using the LCD buttons: obstacles (m and w for now because they are symmetrical) would shift left while the player (A for now) would "dodge" or jump up and down to avoid the obstacles. Then I added the buttons to the board and I struggled to get the game to work again. I totally forget what debouncing was and why it was important so I had to scrape through my EE109 docs to try to relearn debouncing, I figured it out, had to change my code way more than I would've thought then I finally had the buttons working. Next I added scoring. For this I used a timer (timer1) and decided that the score should be based on time and specifically (10 ms). It was at first 1 every second but then your score is only 14 so I changed it to every 10 ms. However, this whole process was a good amount of work as well because I needed to go through the Arduino documentation to remember how to configure the timer and decide which timer is best (I chose timer1 because it's a 16-bit timer so a player could play for 100 minutes and not have any issues with the timer vs timer0 and timer2 you could only do 25 seconds (at least without a slightly more complex configuration besides just outputting the timer's value)). After figuring that out, I wanted to add an LED and I knew I wanted to use the tricolor LED to have both red (for when you lose) and an increasingly bright green light. This is when I realized I wanted some sort of levelUp feature which is where the buzzer comes in. For the LED, once again I had to do research again on what resistors to use and how to orient the LED properly. This wasn't too bad but doing the Pulse Width Modulation (PWM) for the changing brightness LED was very difficult.

reflection: overall the process was generally like this. here is a specific example of how i implemented on of the things in this list.

here are challenges i faced/ things i would want to implement in the future:
talk about the stuff your sister said, the specialized objects

overall it was a fun project, i enjoyed reviewing concepts from EE 109 like interrupts, EEPROM, and PWM. 

my main takeaways are

upload video to youtube

